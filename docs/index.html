<!DOCTYPE HTML>
<html>

	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
		<meta name="viewport" id="viewport" content="width=device-width, initial-scale=2, user-scalable=no" />
		<title>GeoGryph: Tutorial</title>		
		<link rel="icon" type="image/png" href="img/icon.png"/>
		
		<!-- Includes: stylesheets -->
		<link type="text/css" href="css/style.css" rel="stylesheet"/> 		
			<!-- Google Web Fonts Beta: Carrois Gothic (Latin) -->
			<link type="text/css" href="http://fonts.googleapis.com/css?family=Carrois+Gothic" rel="stylesheet"/>		
		
		<!-- Includes: scripts -->		
		
		<!-- Styles -->
		<style>
			* { color: #313131; }
			head { margin: 0; padding: 0; width: 100%; height: 100%; }
			body { margin: 0; padding: 0; width: 100%; height: 100%; background-color: #313131;}
												
			#content
			{							
				margin: 0 auto;				
				padding-left: 15px;
				padding-right: 15px;								
				width: 1000px;
				height: 100%;
				background-color: #EEEECE;
				color: #313131;	
				-moz-box-shadow: 0 1px 10px #000000;
				-webkit-box-shadow: 0 1px 10px #000000;
				box-shadow: 0 1px 10px #000000; 
			}			

			h1, h2
			{
				font-family: Carrois Gothic;
				font-weight: bold;								
			}						
			
			p
			{
				text-align: justify;
			}
			
		</style>		
		
	</head>

	<body>		
	
		<div id="content">
										
			<div id="title" style="text-align: center">
			
				<h1>Developing Apps for BB10 with BlackBerry HTML5 WebWorks</h1>		
				<h2>GeoGryph: An interactive campus map for University of Guelph students using Google Maps and HTML5 Geolocation</h2>
				
			</div>
		
			<div id="introduction">								
				<h3>Introduction</h3>
			</div>
			
			<div id="skill">
				<h3>Required Knowledge & Skills</h3>
			</div>
			
			<div id="tools">		
				<h3>Required Tools & Configurations</h3>
			</div>
			
			<div id="features">
				<h3>Features</h3>
				<p>
					The following are the main features of this application:
					<ul>
						<li>Display the current location of the user on an interactive map</li>
						<li>Trip recorder (see the Geolocation application from Lab #1)</li>
						<li>Find a particular building at the university campus</li>
						<li>Find any point of interest (POI) within the campus area</li>
						<li>Display a path for walking from the user's current location to any other location identified by the above</li>
					</ul>
				</p>
			</div>
			
			<div id="interface">
				<h3>User Interface</h3>
				
				<!-- TODO -->
				
				<h4>Show/Hide More Options</h4>
				<p>
					We complete the user interface by implementing the toggle show/hide feature of the options overlay. We will need to add some JavaScript code for this. Go ahead and open up the <code>skeleton.js</code> file (about time!) in the <code>js</code> folder in your favorite text editor. Locate the <code>toggleOptions</code> function and observe it. The <code>options</code> variable stores the <code>DIV</code> element tagged by the id <code>options_overlay</code>. This is our overlay element. The <code>visibility</code> variable stores the current value of the <code>display</code> attribute of the overlay element. This attribute determines whether the element is hidden or not. Its possible values are the strings <code>"none"</code> (hidden), <code>"inline"</code> (visible) or <code>"block"</code> (visible). The overlay is obviously a block element since it will not be rendered in	line with text, so we implement a toggle mechanism that sets the <code>display</code> attribute of <code>options</code> to <code>"none"</code> when it is <code>"block"</code> and currently <code>"block"</code> when it is currently <code>"none"</code>. This can be accomplished using a simple if-else conditional structure. Recall that we had earlier bound click listeners to the map container (<code>map_canvas</code>). From now on, the options button acts as a toggle switch to show or hide the options overlay. Additionally, clicking anywhere else on the interface except for the toolbar will hide the overlay. This effectively emulates a toggle show/hide mechanism.
				</p>
				
				<h4>Show/Hide the about overlay</h4>
				<p>
					Do the same as above for the <code>about_overlay DIV</code> element to enable its toggle feature. You will need to work with the <code>aboutApp</code> function to accomplish this (note that the code for both <code>aboutApp</code> and <code>toggleOptions</code> should be very similar to each other).
				</p>
			</div>
			
			<div id="backend">
				<h3>Backend Functionality</h3>
				<p>
					Now let us work on the meat of the application. For the rest of this section, you will remain in <code>skeleton.js</code> unless specified otherwise.
				</p>

				<h4>Initialize The Map</h4>	
				<p>
					We first need to deal with some start-up initializations. Take a look at the global variables right now. When the application loads, it first renders the marked up interface followed by the Google Maps object. asd
				</p>												
				

				<h4>Create Marker</h4>
				<p>
					Due to the nature of the application, we will have an indefinite and sometimes large number of markers on the map. In order to efficiently work with them, we store all markers in a global JavaScript object <code>markers</code>. Thus, we abstract the marker creation process into a separate function that appends newly created markers to this object. We will take advantage of the fact that JavaScript objects can function like associative arrays, so each marker is added as a property of the <code>markers</code> object<sup>*Objects as associative arrays</sup>.
					<br/><br/>
					Go to the <code>createMarker(id, position, title, icon)</code> function. The first and most important step is to create the marker object. Assign to <code>marker_options</code> the following properties: the <code>map</code> it belongs to; its <code>position</code> (a <code>google.maps.LatLng</code> object); and a <code>title</code> that briefly describes the marker. The <code>map</code> global variable is obviously the map; the <code>position</code> and <code>title</code> arguments of the function satisfy the next two properties. Now the icon uri that contains the image of the marker is an optional argument to the function, so we need to handle this. This can be done as follows:
<pre>
	if (icon !== undefined)
		marker_options.icon = icon;
</pre>
					We need a unique identifier in order to represent each <code>markers</code> property as a marker object. This is satisfied via the <code>id</code> argument. We now have everything we need to create the marker object, so type the following code:
<pre>
	markers[id] = new google.maps.Marker(marker_options);
</pre>
					Next, we need to create an information window overlay so that when the user clicks on a marker, the name of the location can be seen. Observe the <code>content</code> variable. This string containts the HTML markup for the overlay content. You will notice that the <code>title</code> variable is concatenated within this string. This ensures that the title (which usually is the name of the location) of each marker appears in this overlay/window. Then, the information window is created and its content is assigned, as shown in the function. Lastly, we need to attach click listeners to activate the toggle functionality of the overlay. Notice the two listener bindings. The first one binds a click event to the created marker object. When the marker is clicked, its respective information window pops up. This is done through <code>info_window.open(map, markers[id]);</code>. The second listener binds a click event to the map object. When the map is clicked, any open information window is closed. This works well because the only interactive elements of the map are the map object and the toolbar in the bottom. This is done through <code>info_window.close();</code>. Thus, we enable toggle functionality for the information overlays of created markers.
					<br/><br/>
					We also want to be able to save the location of the marker when clicked so that the user can plot a location from his/her current location to the marker's position. And as a matter of usability, we want to snap the map to the marker's position. These must all be handled by the marker's click listener. The binding code should be modified and must finally look something like this:
<pre>
	google.maps.event.addListener(markers[id], 'click',
		function ()
		{
			saveToLocalStorage(position);
			checkMapZoom(map.getZoom())
			map.setCenter(position);
				
			info_window.open(map, markers[id]);
		}
	);
</pre>					
					For obvious reasons, we do not want to create a new marker for repeated locations. To solve this issue, simply enclose all of the existing function code into a conditional structure. Simply perform a check to see if <code>markers</code> already contains the marker as one of its properties. If <b>yes</b>, then the existing marker is simply placed on the map once again. The conditional structure should look as follows:
<pre>
	if (!markers.hasOwnProperty(id))
	{
		//
		// Function code
		//
	}
	else
		markers[id].setMap(map);
</pre>
					We have now successfully abstracted away the marker creation process from the rest of the application.
				</p>
				
				<h4>Update Markers</h4>
				<p>
					Just as we developed a general method to batch create markers, we also need to be able to update the position(s) of a marker or an array of markers. 
				</p>				
				
				<h4>Request User's Current Location</h4>
				<p>
					Probably the most important functionality of the application is the ability to know the user's current location at any given time. Examine the function <code>getUserLocation(callback, errorCallback)</code> carefully. The signature indicates that it takes in two callback functions as arguments, <code>callback</code> and <code>errorCallback</code> (which is an optional argument). You must already be familiar with using the <code>navigator.geolocation</code> object from the HTML5 specification. To retrieve the user's current position, one would usually just invoke the <code>getCurrentPosition(success, error, options)</code> method and work with the retrieved <code>position</code> object in the <code>success(position)</code> callback function while handling errors in the <code>error(error)</code> callback function. But this only works for one way of using this feature. Since we will be using this feature frequently and in various use cases, we need to abstract away what we do with <code>position</code> from the function. Here is where the <code>callback</code> argument of the function plays its role. The actual processing of the user's position will be done within this callback function. Here is the signature of <code>callback</code>: <code>callback(position)</code>. All we need to do is call <code>callback</code> within the <code>success</code> callback and pass <code>position</code> into it. All this might sound very confusing but all you really have to do is add 1 line of code. Here is what the entire code looks like so far:
<pre>
	// Geolocation services must be enabled
	if (navigator.geolocation)
	{
		navigator.geolocation.getCurrentPosition(			
 			function (position)
			{					
				// Do something with the current position
				callback(position);
			}
			// Deal with errors
			, function (error)
			{
				switch(error.code)
				{
					case error.PERMISSION_DENIED:
						alert("Error: Denied access to location services!");
						break;
				}				
			}
		, {enableHighAccuracy: true});
	} 
</pre>										
					Note that basic error-handling has been done that checks if location services are supported/enabled by the device. But we have not yet properly handled the case that it is not supported. Create an <code>else</code> structure associated with the <code>if</code> structure.  Additionally, complete the <code>switch</code> structure to include the following cases: <code>POSITION_UNAVAILABLE</code>, <code>TIMEOUT</code> and <code>UNKNOWN_ERROR</code>. We also do not want to simply notify the user if the geolocation request returned an error, so we call the <code>errorCallback()</code> function right after the <code>switch</code> structure to handle the error. Now, recall that the error callback function is an optional argument, therefore check if it was provided. If <b>yes</b>, execute it; if <b>not</b>, simply ignore it or notify the user that geolocation services are not supported/enabled by the device, whichever you need to do. The entire function should now look something like this:
<pre>
	if (navigator.geolocation)
	{
		navigator.geolocation.getCurrentPosition(			
 			function (position)
			{					
				// Do something with the current position
				callback(position);
			}
			// Deal with errors
			, function (error)
			{
				switch(error.code)
				{
					case error.PERMISSION_DENIED:
						alert("Error: Denied access to location services!");
						break;
					//
					// Perform other switch cases
					//
				}		
				// Call the error callback function if provided, else do nothing
				if (errorCallback !== undefined)
					errorCallback();
			}
		, {enableHighAccuracy: true});
	}
	else
	{
		// If the error callback function is not provided, just notify the user
		if (errorCallback === undefined)
			alert("Error: Geolocation services are not supported by your device!");
		else
			errorCallBack();
	}
</pre>				
					We now have a flexible function for retrieving the current location of the user whenever needed.
				</p>
				
				<h4>Snap To User</h4>
				<p>
					The primal feature of the application is being able to snap/center the map on the user's current location. Consider the very straightforward function <code>snap()</code>. It requests the user's current location by calling <code>getUserLocation(callback, errorCallback)</code> as defined above. The returned position must then be parsed and stored as a <code>google.maps.LatLng</code> object in a <code>location</code> variable. The user marker object is then associated with this location and the map is snapped to this point. The code you need to write for the anonymous callback function is something like the following:
<pre>
	function (position)
	{
		var location = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);		
		updateMarkers([markers.user], [location], location);
	}
</pre>				
					Note that the first two parameters of <code>updateMarkers(markers, positions, center?)</code> require arrays of markers and positions, respectively. Hence, we enclose the single entries within brackets. Also note that in this case, the optional argument for centering the map is passed, since we want to snap/center the map on the user's location.
					<br/><br/>
					Finally, examine the anonymous callback function that handles the error callback for <code>getUserLocation(callback, errorCallback)</code>. If geolocation services fail for some reason, the map is centered on a predefined location. In this case (as well as the rest of the application), the location is the intersection of Stone Road and Gordon Street.
					<br/><br/>
					Our application can now snap to the user's location as desired. We will follow the template and general structure of this function for some other functions as well.
				</p>
				
				<h4>Save User's Current Location</h4>
				<p>
					An important aspect of the Trip Recorder feature is the ability to save the user's current location persistently and then access it at a later time for processing. This can be very easily accomplished following the structure of the <code>snap()</code> function that we just finished above. Go to the <code>save()</code> function and copy the contents of <code>snap()</code> into it. The function should look something like this:
<pre>
	getUserLocation(
		function (position)
		{
			var location = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);			
			updateMarkers([markers.user], [location], location);				
		},
		function ()
		{
			map.setCenter(stone_gordon);
		}
	); 
</pre>					
					We are doing exactly the same thing as before with the one exception that instead of updating the position of any marker, we save the user's current location in local web storage. To do this, delete the <code>updateMarkers</code> line and replace it with a call to <code>saveToLocalStorage(location)</code>. Your final code should be something like this:
<pre>
	getUserLocation(
		function (position)
		{
			var location = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);			
			saveToLocalStorage(location);
		},
		function ()
		{
			map.setCenter(stone_gordon);
		}
	); 
</pre>				
					As a side note, we are automatically handling the error callback due to the copying of the previous code.
					<br/><br/>
					Thus, our application can now save a locaton persistently in the local web storage of the user's device/browser.
				</p>
				
				<h4>Save Location For Later Use</h4>
				<p>
					One of the main features of the application is to store any desired location for reuse at a later time. This means that we need data that persists even after the app has been closed. The local web storage API defined as part of the HTML5 standard is a fine (and elegant) solution to this problem. Go to the <code>saveToLocalStorage(location)</code> function. It takes the <code>location</code> object, which is expected to be of type <code>google.maps.LatLng</code>, as an argument and stores it in the local web storage of the user's device.  First, create a JavaScript object<sup>*(JS object vs. JSON object)</sup> <code>data</code>. This object must have two properties, <code>lat</code> and <code>lng</code>, for storing the latitude and longitude of the <code>location</code> object separately. A <code>google.maps.LatLng</code> object has two methods, <code>lat()</code> and <code>lng()</code>. But these return <code>number</code> values, and not strings. Thus, we need to store in <code>data</code> the string representations of the values returned by the methods. Next, we need to convert <code>data</code> into a JSON object (string) because only strings can be stored in the local storage and we need a meaningful way to represent the <code>data</code> object. Store the resultant string in a variable <code>storage_string</code>. Now, consider the <code>localStorage</code> object that is provided as part of the API. It is a persistent object and its values do not change or reset even when the application is closed and re-opened. We obviously want to add our data somehow to this object so that it can be persistent as well. This can be done by creating a new property <code>savedLocation</code> and then storing the string representation of our data into this property. Your code should now look something like this:
<pre>
	// Store the latitude and longitude in a convenient object
	var data = 
	{
		lat: (location.lat()).toString(),
		lng: (location.lng()).toString()
	};		
	
	// Convert to a JSON string so it can be saved in local web storage
	var storage_string = JSON.stringify(data);	
	localStorage.savedLocation = storage_string;
</pre>
					As a final touch, it would be nice if the map snapped to the location after saving it. This is a usability enhancement and just makes it easier for the user to be location-aware. To do this, simply center the map on the <code>location</code> object. Just to recall, the code for this would be:
<pre>
	map.setCenter(location);
</pre>					
					We are not done yet: there is one crucial thing missing from this entire code so far. It is quite unreasonable to expect that all devices and user agents support the HTML5 local web storage API. Thus, we need to handle this and notify the user accordingly. To check for the existence of this feature, you can simply check for <code>window.localStorage</code>. When used as a predicate for a conditional structure (like an <code>if</code>-statement), it evaluates to <code>true</code> if local storage is supported and <code>false</code> if not. Wrap the entire code we have written for this function so far in an <code>if</code> structure and produce an <code>alert</code> for the <code>else</code> part. Here is an illustration:
<pre>
	if (window.localStorage)
	{
		// Enter all code for this function, including the snapping of the map
	}
	else
		alert("Error: localStorage is not supported by your device!");
</pre>
					Our application is now able to store persistent data.
				</p>
				

				<h4>Mark Building On Map</h4>
				<p>
				</p>				
				
				<h4>Load Last Saved Location</h4>
				<p>
					Once we have stored our data persistently, we must also be able to access it from local storage whenever its use is required. Take a look at the <code>loadFromLocalStorage()</code> function. Since we will be using the local web storage API once again, we obviously need to check to see if it is supported. You can see a conditional structure there exactly like the one from the <code>saveToLocalStorage(location)</code> function that we previously worked on. All we need to do is load the previously saved string representation of the location into a <code>google.maps.LatLng</code> object and then return this object to the caller. Recall that in the <code>saveToLocalStorage(location)</code> function, we used the <code>JSON.stringify(object)</code> method to convert <code>data</code> to a JSON string and stored it in <code>localStorage.savedLocation</code>. So we just need to get back the <code>data</code> object from <code>localStorage.savedLocation</code>, and we can do this by parsing the string using <code>JSON.parse(string)</code>. Store this in <code>data</code>, create a location object using <code>data.lat</code> and <code>data.lng</code> and then return this location. Your code should now look something like this:
<pre>
	var data = JSON.parse(localStorage.savedLocation);
	var loaded_location = new google.maps.LatLng(data.lat, data.lng);
	
	return loaded_location;	
</pre>					
					Our function will now load and return the last saved location, as long as the local storage API is supported. But we are missing one crucial boundary case: what if there is no previously saved location in the first place? This would be the case when the application is run for the very first time, or if the local web storage was cleared/deleted. In order to handle this, we need to check if the <code>localStorage</code> object has the property <code>savedLocation</code>. If this is not true, then notify the user and return <code>undefined</code>.
					<br/><br/>					
					You will understand the reasoning behind returning <code>undefined</code> when we use this function later.
				</p>				
				
				<h4>Render Path</h4>
				<p>
					The <code>render(origin, destination)</code> helper function takes in two arguments, <code>origin</code> and <code>destination</code>, which are of type <code>google.maps.LatLng</code>. These obviously are the two points between which a path needs to be drawn. To create this path, we need to compute the directions from the origin point to the destination point. This is done using the Google Directions API. Note the global variables <code>directions_service</code> and <code>directions_display</code>. They were initialized as <code>google.maps.DirectionsService</code> and <code>google.maps.DirectionsRenderer</code> objects respectively. These are required in order to subscribe to the Directions API, as mentioned earlier. Now get into the function and take a look at its code. The <code>request</code> object contains three self-explanatory properties that form the parameters for the Directions API request. We then invoke the <code>route(request, callback)</code> method in order to compute the directions between <code>origin</code> and <code>destination</code>. The callback function is used to do something with the response. It needs to pass two arguments: <code>result</code>, which contains the results of the request, and <code>status</code> which indicates the status of the response. So create an anonymous function of the same signature and then create an <code>if</code> conditional structure that checks if <code>status</code> evaluates to <code>google.maps.DirectionsStatus.OK</code>. Within this structure (i.e. if the condition is true, then) use <code>directions_display</code> to render the polyline represented by the resultant directions on the map. Additionally, snap the map to the destination point (or the origin point; whichever you prefer) so that the user always sees where he/she needs to go to (or where he/she is present at the moment). Your anonymous function should look something like this:
<pre>
	function (result, status)
	{
		if (status == google.maps.DirectionsStatus.OK)
		{
			// Render the directions polyline
			directions_display.setMap(map);
			directions_display.setDirections(result);
			map.setCenter(destination);
		}
	}
</pre>
					We have now created the helper function for actually rendering the polyline path between two points on the map. This function can be called by <code>plot()</code> if the origin must be evaluated as the user's current location. If another origin point is known, the function can be called directly as well.
				</p>
				
				<h4>Plot Path Between Locations</h4>
				<p>
					Another main feature of the application is to be able to plot a path between an origin point (currently, always the user's current location) and a destination point. Examine the <code>plot(destination)</code> function. It is evident that the function takes in a destination location as an object, computes the user's current location and then renders the path between these two points. Note that <code>destination</code> is actually an optional argument, so if it is not provided, the function by default attempts to load a destination from local web storage. So first check if the argument was provided; if <b>not</b>, then call the <code>loadFromLocalStorage()</code> function and store its return value in <code>destination</code>. You can do this as follows:
<pre>
	// If a destination has not been provided, load from local web storage (HTML 5)
	if (destination === undefined)
		destination = loadFromLocalStorage();
</pre>
					We now need to retrieve the user's current location. As usual, call <code>getUserLocation(callback)</code> and pass in an anonymous function that is quite similar to the one in the <code>snap()</code> function. Make sure first that the latitude and longitude values from the returned position are stored in a variable <code>origin</code> as opposed to <code>location</code> from previous functions (this is just for easier readability). We now have all the information we need to draw a path between the two points. Call <code>render(origin, destination</code> and pass the two arguments appropriately. This renders a blue polyline from the origin point to the destination point but does not draw any markers on the map. To do this we need to update the positions of the user (<code>markers.user</code>) and destination (<code>markers.destination</code>) objects (as opposed to creating brand new objects, which is inefficient). Thus, we create an array containing the markers <code>markers.user</code> and <code>markers.destination</code>. Create another array containing the positions <code>origin</code> and <code>destination</code>. Now call <code>updateMarkers(markers, positions, center?)</code> and pass the two arrays in the correct order, omitting the third argument. The anonymous function should look something like this:
<pre>
	function (position)
	{
		// Retrieve user's current location
		var origin = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);
			
		render(origin, destination);
		
		var markers_array = [markers.user, markers.destination];
		var positions_array = [origin, destination];
		updateMarkers(markers_array, positions_array);		
	}
</pre>
					The main functionality is now complete but we need to check for one erroneous case: when <code>destination</code> is <code>undefined</code>, i.e. no destination was passed as an argument <b>nor</b> is there any destination stored in the local web storage. We have already handled the former case but in the case of the latter, note that <code>loadFromLocalStorage()</code> returns <code>undefined</code> if there was no location previously saved in the local web storage. This should make it clear why this case needs to be handled, which is very easy to do so. Simply put the portion after the former check within a conditional structure that checks if <code>destination</code> is not <code>undefined</code>. Your conditional structure should be something like this:
<pre>
	if (destination !== undefined) // Ensure that a destination does exist
	{		
		getUserLocation(
			function (position)
			{
				// etc. etc. as instructed above
			}
		),
		function ()
		{
			map.setCenter(stone_gordon);
		}
	);
	}
</pre>
					Thus, we can now plot a path between two locations on the map.
				</p>
					

				<h4>Search For POIs</h4>
				<p>
				</p>
				
				<h4>Restrict Map Zoom Level</h4>
				<p>
					It is normally expected that the user of a maps-based application will use the zoom feature of the map to their advantage. The problem with this lies in the way web-based applications render the map object. Each state of the map has a number of images associated with it. Whenever a new state is reached, these images must be downloaded to the applications. States are changed by zooming, panning and some other operations. If the user zooms quite often, the performance of the app is expected to reduce significantly, especially on mobile devices. Additionally, unnecessary usage expenses are incurred for those who use 2G/3G/LTE networks. In order to gain more performance as well as more usability, this application restricts how much the user can zoom in/out the map by a fixed amount. 
					<br/><br/>
					Implementing this is very trivial. Go to the <code>checkMapZoom(current_zoom)</code> function. At any given state, the map is at a specific level of zoom which ranges between 1-19. The argument <code>current_zoom</code> contains this value, which must be passed by the caller. Note the two global variables <code>min_zoom</code> and <code>desired_zoom</code>. These parameters describe the restriction level (note that <code>min_zoom</code> must always be less than or equal to <code>desired_zoom</code>). Whenever the current zoom level is <b>greater than or equal to</b> the desired zoom level, we need not change the zoom level of the map. This ensures that no change of state by zooming occurs when the user has zoomed in quite a bit. But whenever it is <b>less than</b> the desired zoom level, we then need to check if it is <b>also less than</b> the minimum zoom level. If <b>yes</b>, then the map's zoom level is reset to the minimum zoom level. This is done to prevent the user from zooming too far out, thus preventing cases of the need to rectify excess zooming. <b>Else</b>, nothing needs to be done again. Here is what the code should look like:
<pre>
	// Restricts the possible zoom levels of the map
	function checkMapZoom (current_zoom)
	{	
		if (current_zoom &#60; desired_zoom)
		{		
			if (current_zoom &#60; min_zoom)	
				map.setZoom(min_zoom);				
		}
	}
</pre>				
					Note that <code>desired_zoom</code> might be more appropriately named as <code>default_zoom</code>. Both names are semantically acceptable; it is up to your discretion which one to use. Also note that the desired zoom level and minimum zoom level parameters can be changed as desired. Additionally, a maximum zoom level parameter can also be defined and used in this function to restrict how close the user can zoom in. This is optional and is thus left to the reader to implement it if desired.
					<br/><br/>
					Thus, we are now able to restrict the zoom level as desired. 
				</p>				
				
							
				

																											
				
				<h4>Refresh The Map</h4>
				<p>
					When the user continues using the app for a prolonged period of time without closing it, the map will eventually become cluttered with markers and polyline paths. This significantly bogs down performance and makes it hard to navigate through the map. To remedy this, we need a way to remove all overlays from the map, thereby "refreshing" it. Go to the <code>clear()</code> function towards the end of the code. Our goal is to 1) clear any text in the search text entry field, 2) clear all rendered markers and 3) clear all rendered paths.
					<br/>
					<ol>
						<li>
							<h4>Clear the search box</h4>
							<p>
								Get the search field element from the markup and store it in a variable <code>search_box</code>. Assign the <code>value</code> attribute<sup>*(attribute vs. property)</sup> as <code>""</code>. This effectively clears the text entry field.
							</p>
						</li>
						<li>
							<h4>Clear all rendered markers</h4>
							<p>
								Recall that all created markers are stored in the <code>markers</code> global array variable. We need to iterate through this array and bind each marker to the <code>null</code> map. To do this operation, invoke <code>setMap(null)</code> for each marker object.
							</p>
						</li>
						<li>
							<h4>Clear all rendered paths</h4>
							<p>
								Similar to above, we need to bind the DirectionsRenderer object to the <code>null</code> map. Invoke <code>setMap(null)</code> for the <code>directions_display</code> variable.
							</p>
						</li>
					</ol>
					We have thus refreshed the entire map and have even cleared the search text entry field.					
				</p>
				
				<h4>Empty Local Storage</h4>
				<p>
					The user might want to clear their local web storage from time to time. This is similar to deleting cookies at the end of a browser session. This is very easy to accomplish. Go to the <code>clearStorage</code> function. All we need to do is clear the contents of the <code>localStorage.savedLocation</code> variable. In JavaScript, you can do this by typing <code>delete localStorage.savedLocation;</code>. This will set <code>localStorage.savedLocation</code> to <code>undefined</code>. It is probably advisable to notify the user of this operation, so go ahead and send an <code>alert("Notice: All saved locations have been cleared!");</code> after the line. 
					<br/><br/>
					Finally, realize that we once again can not expect all users' devices/browsers to support HTML5 local storage, so we must check for this and notify the user accordingly just as we did earlier.
				</p>
			</div>
			
			<div id="testing">
				<h3>Testing & Debugging</h3>
			</div>
			
			<div id="conclusion">	
				<h3>Conclusion</h3>
			</div>
			
			<div id="appendix_a">
				<h3>Appendix A: Solutions to mini-challenges</h3>
			</div>
	
		</div>
			
	</body>
	
	
</html>