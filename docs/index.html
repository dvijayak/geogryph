<!DOCTYPE HTML>
<html>

	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
		<meta name="viewport" id="viewport" content="width=device-width, initial-scale=2, user-scalable=no" />
		<title>GeoGryph: Tutorial</title>		
		<link rel="icon" type="image/png" href="img/icon.png"/>
		
		<!-- Includes: stylesheets -->
		<link type="text/css" href="css/style.css" rel="stylesheet"/> 		
			<!-- Google Web Fonts Beta: Carrois Gothic (Latin) -->
			<link type="text/css" href="http://fonts.googleapis.com/css?family=Carrois+Gothic" rel="stylesheet"/>		
		
		<!-- Includes: scripts -->		
		
		<!-- Styles -->
		<style>
			* { color: #313131; }
			head { margin: 0; padding: 0; width: 100%; height: 100%; }
			body { margin: 0; padding: 0; width: 100%; height: 100%; background-color: #313131;}
												
			#content
			{							
				margin: 0 auto;				
				padding-left: 15px;
				padding-right: 15px;								
				width: 1000px;
				height: 100%;
				background-color: #EEEECE;
				color: #313131;				
			}			

			h1, h2
			{
				font-family: Carrois Gothic;
				font-weight: bold;				
				text-shadow: 1px 1px #999999
			}						
			
			p
			{
				text-align: justify;
			}
			
		</style>		
		
	</head>

	<body>		
	
		<div id="content">
										
			<div id="title" style="text-align: center">
			
				<h1>Developing Apps for BB10 with BlackBerry HTML5 WebWorks</h1>		
				<h2>GeoGryph: An interactive campus map for University of Guelph students using Google Maps and HTML5 Geolocation</h2>
				
			</div>
		
			<div id="introduction">								
				<h3>Introduction</h3>
			</div>
			
			<div id="skill">
				<h3>Required Knowledge & Skills</h3>
			</div>
			
			<div id="tools">		
				<h3>Required Tools & Configurations</h3>
			</div>
			
			<div id="features">
				<h3>Features</h3>
				<p>
					The following are the main features of this application:
					<ul>
						<li>Display the current location of the user on an interactive map</li>
						<li>Trip recorder (see the Geolocation application from Lab #1)</li>
						<li>Find a particular building at the university campus</li>
						<li>Find any point of interest (POI) within the campus area</li>
						<li>Display a path for walking from the user's current location to any other location identified by the above</li>
					</ul>
				</p>
			</div>
			
			<div id="interface">
				<h3>User Interface</h3>
				
				<!-- TODO -->
				
				<h4>Show/Hide More Options</h4>
				<p>
					We complete the user interface by implementing the toggle show/hide feature of the options overlay. We will need to add some JavaScript code for this. Go ahead and open up the <code>skeleton.js</code> file (about time!) in the <code>js</code> folder in your favorite text editor. Locate the <code>toggleOptions</code> function and observe it. The <code>options</code> variable stores the <code>DIV</code> element tagged by the id <code>options_overlay</code>. This is our overlay element. The <code>visibility</code> variable stores the current value of the <code>display</code> attribute of the overlay element. This attribute determines whether the element is hidden or not. Its possible values are the strings <code>"none"</code> (hidden), <code>"inline"</code> (visible) or <code>"block"</code> (visible). The overlay is obviously a block element since it will not be rendered in	line with text, so we implement a toggle mechanism that sets the <code>display</code> attribute of <code>options</code> to <code>"none"</code> when it is <code>"block"</code> and currently <code>"block"</code> when it is currently <code>"none"</code>. This can be accomplished using a simple if-else conditional structure. Recall that we had earlier bound click listeners to the map container (<code>map_canvas</code>). From now on, the options button acts as a toggle switch to show or hide the options overlay. Additionally, clicking anywhere else on the interface except for the toolbar will hide the overlay. This effectively emulates a toggle show/hide mechanism.
				</p>
				
				<h4>Show/Hide the about overlay</h4>
				<p>
					Do the same as above for the <code>about_overlay DIV</code> element to enable its toggle feature. You will need to work with the <code>aboutApp</code> function to accomplish this (note that the code for both <code>aboutApp</code> and <code>toggleOptions</code> should be very similar to each other).
				</p>
			</div>
			
			<div id="backend">
				<h3>Backend Functionality</h3>
				<p>
					Now let us work on the meat of the application. For the rest of this section, you will remain in <code>skeleton.js</code> unless specified otherwise.
				</p>

				<h4>Initialize The Map</h4>	
				<p>
					We first need to deal with some start-up initializations. Take a look at the global variables right now. When the application loads, it first renders the marked up interface followed by the Google Maps object. asd
				</p>												
				
				
				<h4>Mark Building On Map</h4>
				<p>
				</p>
				
				<h4>Snap To User</h4>
				<p>
				</p>
				
				<h4>Save User's Current Location</h4>
				<p>
				</p>
				
				<h4>Plot Path Between Locations</h4>
				<p>
				</p>
				
				<h4>Search For POIs</h4>
				<p>
				</p>
				
				<h4>Restrict Map Zoom Level</h4>
				<p>
				</p>				
				
				<h4>Render Path</h4>
				<p>
				</p>								
				
				<h4>Create Marker</h4>
				<p>
				</p>
				
				<h4>Update Markers</h4>
				<p>
				</p>
				
				<h4>Request User's Current Location</h4>
				<p>
					Probably the most important functionality of the application is the ability to know the user's current location at any given time. Examine the function <code>getUserLocation(callback, errorCallback)</code> carefully. The signature indicates that it takes in two callback functions as arguments, <code>callback</code> and <code>errorCallback</code> (which is an optional argument). You must already be familiar with using the <code>navigator.geolocation</code> object from the HTML5 specification. To retrieve the user's current position, one would usually just invoke the <code>getCurrentPosition(success, error, options)</code> method and work with the retrieved <code>position</code> object in the <code>success(position)</code> callback function while handling errors in the <code>error(error)</code> callback function. But this only works for one way of using this feature. Since we will be using this feature frequently and in various use cases, we need to abstract away what we do with <code>position</code> from the function. Here is where the <code>callback</code> argument of the function plays its role. The actual processing of the user's position will be done within this callback function. Here is the signature of <code>callback</code>: <code>callback(position)</code>. All we need to do is call <code>callback</code> within the <code>success</code> callback and pass <code>position</code> into it. All this might sound very confusing but all you really have to do is add 1 line of code. Here is what the entire code looks like so far:
<pre>
	// Geolocation services must be enabled
	if (navigator.geolocation)
	{
		navigator.geolocation.getCurrentPosition(			
 			function (position)
			{					
				// Do something with the current position
				callback(position);
			}
			// Deal with errors
			, function (error)
			{
				switch(error.code)
				{
					case error.PERMISSION_DENIED:
						alert("Error: Denied access to location services!");
						break;
				}				
			}
		, {enableHighAccuracy: true});
	} 
</pre>										
					Note that basic error-handling has been done that checks if location services are supported/enabled by the device. But we have not yet properly handled the case that it is not supported. Create an <code>else</code> structure associated with the <code>if</code> structure.  Additionally, complete the <code>switch</code> structure to include the following cases: <code>POSITION_UNAVAILABLE</code>, <code>TIMEOUT</code> and <code>UNKNOWN_ERROR</code>. We also do not want to simply notify the user if the geolocation request returned an error, so we call the <code>errorCallback()</code> function right after the <code>switch</code> structure to handle the error. Now, recall that the error callback function is an optional argument, therefore check if it was provided. If yes, execute it; if not, simply ignore it or notify the user that geolocation services are not supported/enabled by the device, whichever you need to do. The entire function should now look something like this:
<pre>
	if (navigator.geolocation)
	{
		navigator.geolocation.getCurrentPosition(			
 			function (position)
			{					
				// Do something with the current position
				callback(position);
			}
			// Deal with errors
			, function (error)
			{
				switch(error.code)
				{
					case error.PERMISSION_DENIED:
						alert("Error: Denied access to location services!");
						break;
					//
					// Perform other switch cases
					//
				}		
				// Call the error callback function if provided, else do nothing
				if (errorCallback !== undefined)
					errorCallback();
			}
		, {enableHighAccuracy: true});
	}
	else
	{
		// If the error callback function is not provided, just notify the user
		if (errorCallback === undefined)
			alert("Error: Geolocation services are not supported by your device!");
		else
			errorCallBack();
	}
</pre>				
					We now have a flexible function for retrieving the current location of the user whenever needed.
				</p>												

				<h4>Save Location For Later Use</h4>
				<p>
					One of the main features of the application is to store any desired location for reuse at a later time. This means that we need data that persists even after the app has been closed. The local web storage API defined as part of the HTML5 standard is a fine (and elegant) solution to this problem. Go to the <code>saveToLocalStorage(location)</code> function. It takes the <code>location</code> object, which is expected to be of type <code>google.maps.LatLng</code>, as an argument and stores it in the local web storage of the user's device.  First, create a JavaScript object<sup>*(JS object vs. JSON object)</sup> <code>data</code>. This object must have two properties, <code>lat</code> and <code>lng</code>, for storing the latitude and longitude of the <code>location</code> object separately. A <code>google.maps.LatLng</code> object has two methods, <code>lat()</code> and <code>lng()</code>. But these return <code>number</code> values, and not strings. Thus, we need to store in <code>data</code> the string representations of the values returned by the methods. Next, we need to convert <code>data</code> into a JSON object (string) because only strings can be stored in the local storage and we need a meaningful way to represent the <code>data</code> object. Store the resultant string in a variable <code>storage_string</code>. Now, consider the <code>localStorage</code> object that is provided as part of the API. It is a persistent object and its values do not change or reset even when the application is closed and re-opened. We obviously want to add our data somehow to this object so that it can be persistent as well. This can be done by creating a new property <code>savedLocation</code> and then storing the string representation of our data into this property. Your code should now look something like this:
<pre>
	// Store the latitude and longitude in a convenient object
	var data = 
	{
		lat: (location.lat()).toString(),
		lng: (location.lng()).toString()
	};		
	
	// Convert to a JSON string so it can be saved in local web storage
	var storage_string = JSON.stringify(data);	
	localStorage.savedLocation = storage_string;
</pre>
					As a final touch, it would be nice if the map snapped to the location after saving it. This is a usability enhancement and just makes it easier for the user to be location-aware. To do this, simply center the map on the <code>location</code> object. Just to recall, the code for this would be:
<pre>
	map.setCenter(location);
</pre>					
					We are not done yet: there is one crucial thing missing from this entire code so far. It is quite unreasonable to expect that all devices and user agents support the HTML5 local web storage API. Thus, we need to handle this and notify the user accordingly. To check for the existence of this feature, you can simply check for <code>window.localStorage</code>. When used as a predicate for a conditional structure (like an <code>if</code>-statement), it evaluates to <code>true</code> if local storage is supported and <code>false</code> if not. Wrap the entire code we have written for this function so far in an <code>if</code> structure and produce an <code>alert</code> for the <code>else</code> part. Here is an illustration:
<pre>
	if (window.localStorage)
	{
		// Enter all code for this function, including the snapping of the map
	}
	else
		alert("Error: localStorage is not supported by your device!");
</pre>
					Our application is now able to store persistent data.
				</p>
				
				<h4>Load Last Saved Location</h4>
				<p>
					Once we have stored our data persistently, we must also be able to access it from local storage whenever its use is required. Take a look at the <code>loadFromLocalStorage()</code> function. Since we will be using the local web storage API once again, we obviously need to check to see if it is supported. You can see a conditional structure there exactly like the one from the <code>saveToLocalStorage(location)</code> function that we previously worked on. All we need to do is load the previously saved string representation of the location into a <code>google.maps.LatLng</code> object and then return this object to the caller. Recall that in the <code>saveToLocalStorage(location)</code> function, we used the <code>JSON.stringify(object)</code> method to convert <code>data</code> to a JSON string and stored it in <code>localStorage.savedLocation</code>. So we just need to get back the <code>data</code> object from <code>localStorage.savedLocation</code>, and we can do this by parsing the string using <code>JSON.parse(string)</code>. Store this in <code>data</code>, create a location object using <code>data.lat</code> and <code>data.lng</code> and then return this location. Your code should now look something like this:
<pre>
	var data = JSON.parse(localStorage.savedLocation);
	var loaded_location = new google.maps.LatLng(data.lat, data.lng);
	
	return loaded_location;	
</pre>					
					Our function will now load and return the last saved location, as long as the local storage API is supported. But we are missing one crucial boundary case: what if there is no previously saved location in the first place? This would be the case when the application is run for the very first time, or if the local web storage was cleared/deleted. In order to handle this, we need to check if the <code>localStorage</code> object has the property <code>savedLocation</code>. If this is not true, then notify the user and return <code>undefined</code>.
					<br/><br/>					
					You will understand the reasoning behind returning <code>undefined</code> when we use this function later.
				</p>				
				
				<h4>Refresh The Map</h4>
				<p>
					When the user continues using the app for a prolonged period of time without closing it, the map will eventually become cluttered with markers and polyline paths. This significantly bogs down performance and makes it hard to navigate through the map. To remedy this, we need a way to remove all overlays from the map, thereby "refreshing" it. Go to the <code>clear()</code> function towards the end of the code. Our goal is to 1) clear any text in the search text entry field, 2) clear all rendered markers and 3) clear all rendered paths.
					<br/>
					<ol>
						<li>
							<h4>Clear the search box</h4>
							<p>
								Get the search field element from the markup and store it in a variable <code>search_box</code>. Assign the <code>value</code> attribute<sup>*(attribute vs. property)</sup> as <code>""</code>. This effectively clears the text entry field.
							</p>
						</li>
						<li>
							<h4>Clear all rendered markers</h4>
							<p>
								Recall that all created markers are stored in the <code>markers</code> global array variable. We need to iterate through this array and bind each marker to the <code>null</code> map. To do this operation, invoke <code>setMap(null)</code> for each marker object.
							</p>
						</li>
						<li>
							<h4>Clear all rendered paths</h4>
							<p>
								Similar to above, we need to bind the DirectionsRenderer object to the <code>null</code> map. Invoke <code>setMap(null)</code> for the <code>directions_display</code> variable.
							</p>
						</li>
					</ol>
					We have thus refreshed the entire map and have even cleared the search text entry field.					
				</p>
				
				<h4>Empty Local Storage</h4>
				<p>
					The user might want to clear their local web storage from time to time. This is similar to deleting cookies at the end of a browser session. This is very easy to accomplish. Go to the <code>clearStorage</code> function. All we need to do is clear the contents of the <code>localStorage.savedLocation</code> variable. In JavaScript, you can do this by typing <code>delete localStorage.savedLocation;</code>. This will set <code>localStorage.savedLocation</code> to <code>undefined</code>. It is probably advisable to notify the user of this operation, so go ahead and send an <code>alert("Notice: All saved locations have been cleared!");</code> after the line. 
					<br/><br/>
					Finally, realize that we once again can not expect all users' devices/browsers to support HTML5 local storage, so we must check for this and notify the user accordingly just as we did earlier.
				</p>
			</div>
			
			<div id="testing">
				<h3>Testing & Debugging</h3>
			</div>
			
			<div id="conclusion">	
				<h3>Conclusion</h3>
			</div>
			
			<div id="appendix_a">
				<h3>Appendix A: Solutions to mini-challenges</h3>
			</div>
	
		</div>
			
	</body>
	
	
</html>